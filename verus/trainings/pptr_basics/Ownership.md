改めて所有権の理解は必要

- Rustの各値は、所有者と呼ばれる変数と対応している。
- いかなる時も所有者は一つである。
- 所有者がスコープから外れたら、値は破棄される。

let x = 42; スタック上のメモリの所有者
let y = Box::new(55); ヒープ上のメモリの所有者

let raw = &x; // raw は特にメモリの所有者ではない 42 の所有者は x であり、raw はそれを参照しているだけ。

let z = *raw // ここでは move が試みられる。


| 宣言                    | mut が指す対象 | 中身を書き換えられる？      | 再代入できる？         |
| --------------------- | --------- | ---------------- | --------------- |
| `let mut a = 1;`      | 値（`i32`）  | ✅ `a = 2`        | ✅               |
| `let mut r = &a;`     | 参照先の束縛    | ❌ `*r = ...` は不可 | ✅ `r = &b`      |
| `let r = &mut a;`     | 値の参照      | ✅ `*r = ...`     | ❌ `r = ...` は不可 |
| `let mut r = &mut a;` | 値の参照 + 束縛 | ✅ `*r = ...`     | ✅ `r = &mut b`  |

| 型          | 名前      | 説明            | 安全性      | 借用チェック |
| ---------- | ------- | ------------- | -------- | ------ |
| `&T`       | 共有参照    | 読み取り専用、安全     | ✅ safe   | ✅ 借用あり |
| `&mut T`   | 可変参照    | 書き換え可能、安全     | ✅ safe   | ✅ 借用あり |
| `*const T` | 不変生ポインタ | 読み取り専用、unsafe | ❌ unsafe | ❌ 借用なし |
| `*mut T`   | 可変生ポインタ | 書き換え可能、unsafe | ❌ unsafe | ❌ 借用なし |

| 操作                        | 型が `Copy` | 安全？      | 所有権問題        |
| ------------------------- | --------- | -------- | ------------ |
| `let x = *ptr;`           | ✅ 必須      | unsafe   | 所有権 move 扱い  |
| `let x = &*ptr;`          | 不問        | unsafe   | 借用として読むだけ    |
| `let x = ptr::read(ptr);` | 不問        | ❌ unsafe | メモリをコピーしている |

| 式                   | Copy型      | 非Copy型               | 備考              |
| ------------------- | ---------- | -------------------- | --------------- |
| `let y = *r;`       | ✅ Copy（複製） | ❌ move → コンパイルエラー    |                 |
| `let y = *b;` (Box) | ✅ OK       | ❌ 非Copyなら move → エラー | `Deref` 経由      |
| `let y = &*r;`      | ✅ OK       | ✅ OK                 | 借用なので move されない |

auto-deref も厄介かもしれない。。

